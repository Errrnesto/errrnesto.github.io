<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transmediator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Roboto Mono', monospace;
      background: #fff;
      color: #000;
      padding: 1rem;
      min-height: 100vh;
    }
    .header {
      text-align: left;
      margin-bottom: 1rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid #eee;
      max-width: 1400px;
      margin-left: auto;
      margin-right: auto;
    }
    h1 { font-size: 1.25rem; font-weight: 500; color: #FF00FF; }
    .subtitle { font-size: 0.7rem; color: #999; margin-top: 0.25rem; }
    .container {
      display: grid;
      grid-template-columns: 1fr 450px;
      gap: 1.5rem;
      max-width: 1400px;
      margin: 0 auto;
    }
    .panel { display: flex; flex-direction: column; }
    .panel-right { width: 450px; }
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    h2 { font-size: 0.8rem; font-weight: 500; }
    .controls { display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; }
    select, button {
      font-family: 'Roboto Mono', monospace;
      font-size: 0.7rem;
      padding: 0.25rem 0.5rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #fff;
      cursor: pointer;
    }
    select:hover, button:hover { border-color: #FF00FF; }
    button.active { background: #FF00FF; color: #fff; border-color: #FF00FF; }
    .input-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: 400px;
    }
    .tab-bar {
      display: flex;
      gap: 0;
      border-bottom: 1px solid #ccc;
    }
    .tab {
      padding: 0.4rem 0.75rem;
      border: 1px solid #ccc;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      background: #f5f5f5;
      cursor: pointer;
      font-size: 0.7rem;
      margin-right: -1px;
    }
    .tab.active { background: #fff; border-bottom: 1px solid #fff; margin-bottom: -1px; }
    .tab:hover { color: #FF00FF; }
    textarea, .hex-editor {
      flex: 1;
      background: #fafafa;
      color: #000;
      border: 1px solid #ccc;
      border-top: none;
      border-radius: 0 0 0.5rem 0.5rem;
      padding: 0.75rem;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.75rem;
      line-height: 1.6;
      resize: none;
      overflow-y: auto;
    }
    textarea:focus, .hex-editor:focus { outline: none; border-color: #FF00FF; border-top-color: #ccc; }
    textarea::placeholder, .hex-editor::placeholder { color: #999; }
    .hex-editor { white-space: pre-wrap; word-break: break-all; }
    .hidden { display: none !important; }
    .progress-bar {
      height: 6px;
      background: #e5e5e5;
      border-radius: 4px;
      margin-top: 0.5rem;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background: #FF00FF;
      transition: width 0.1s;
    }
    .stats {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      color: #666;
      margin-top: 0.25rem;
    }
    .stats .current { color: #FF00FF; }
    .selection-info {
      font-size: 0.65rem;
      color: #FF00FF;
      margin-top: 0.25rem;
      min-height: 1em;
    }
    .preview-section { margin-bottom: 1rem; }
    .preview-label {
      font-size: 0.7rem;
      color: #666;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .canvas-wrapper {
      background: #000;
      border-radius: 0.5rem;
      padding: 4px;
      display: inline-block;
      overflow: auto;
      max-width: 440px;
      max-height: 320px;
    }
    canvas#imageCanvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .zoom-controls { display: flex; gap: 0.25rem; }
    .zoom-btn { min-width: 2.5rem; }
    .waveform-container {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 0.5rem;
      padding: 0.5rem;
      width: 440px;
      max-height: 150px;
    }
    canvas#waveformCanvas { display: block; width: 100%; height: 100px; }
    .audio-controls {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .play-btn {
      background: #FF00FF;
      color: #fff;
      border: none;
      padding: 0.5rem 1rem;
      font-weight: 500;
    }
    .play-btn:hover { background: #cc00cc; }
    .download-btns { display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap; align-items: center; }
    .download-btns .separator { color: #ccc; margin: 0 0.25rem; }
    .upload-warning {
      font-size: 0.7rem;
      color: #cc00cc;
      margin-top: 0.5rem;
      display: none;
    }
    .upload-warning.visible { display: block; }
    .mode-toggle {
      display: flex;
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
    }
    .mode-toggle button {
      border: none;
      border-radius: 0;
      border-right: 1px solid #ccc;
    }
    .mode-toggle button:last-child { border-right: none; }
    .encoding-info {
      font-size: 0.6rem;
      color: #999;
      margin-top: 0.25rem;
    }
    .footer {
      text-align: right;
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid #eee;
      max-width: 1400px;
      margin-left: auto;
      margin-right: auto;
    }
    .footer a {
      font-size: 0.7rem;
      color: #FF00FF;
      text-decoration: none;
    }
    .footer a:hover { text-decoration: underline; }
    @media (max-width: 900px) {
      .container { grid-template-columns: 1fr; }
      .panel-right { width: 100%; }
      .canvas-wrapper, .waveform-container { max-width: 100%; width: 100%; }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>TRANSMEDIATOR</h1>
    <div class="subtitle">Text → Image → Audio | 44,100 bytes = 210×210 px = 1 second</div>
  </div>

  <div class="container">
    <div class="panel">
      <div class="panel-header">
        <h2>Data Input</h2>
        <div class="controls">
          <div class="mode-toggle">
            <button id="grayBtn" class="active" onclick="setMode('gray')">Grayscale</button>
            <button id="rgbBtn" onclick="setMode('rgb')">RGB</button>
          </div>
        </div>
      </div>
      <div class="controls" style="margin-bottom:0.5rem;">
        <select id="encodingSelect" onchange="updatePreview()">
          <option value="unsigned">Unsigned (0–255)</option>
          <option value="signed">Signed (−128–127)</option>
        </select>
        <select id="interleavingSelect" onchange="updatePreview()" class="hidden">
          <option value="interleaved">Interleaved (RGBRGB...)</option>
          <option value="planar">Non-interleaved (RRR...GGG...BBB...)</option>
        </select>
        <button onclick="fillRandom()">Random bytes</button>
      </div>
      
      <div class="input-area">
        <div class="tab-bar">
          <div class="tab active" id="textTab" onclick="switchTab('text')">Text</div>
          <div class="tab" id="hexTab" onclick="switchTab('hex')">Hex</div>
        </div>
        <textarea id="editor" placeholder="Start typing or paste text..."></textarea>
        <textarea id="hexEditor" class="hex-editor hidden" placeholder="Enter hex values (e.g., 48 65 6C 6C 6F)..."></textarea>
      </div>
      
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      <div class="stats">
        <span><span class="current" id="currentCount">0</span> / <span id="maxCount">44,100</span> bytes</span>
        <span id="remainingCount">44,100 remaining</span>
      </div>
      <div class="selection-info" id="selectionInfo"></div>
      <div class="download-btns">
        <button onclick="downloadFile('txt')">.txt</button>
        <button onclick="downloadFile('raw')">.raw</button>
        <span class="separator">|</span>
        <button onclick="document.getElementById('fileInput').click()">Upload file</button>
        <input type="file" id="fileInput" accept=".txt,.raw" style="display:none" onchange="handleFileUpload(event)">
      </div>
      <div class="upload-warning" id="uploadWarning"></div>
    </div>

    <div class="panel panel-right">
      <div class="preview-section">
        <div class="preview-label">
          <span>Image Preview (<span id="imageDims">210×210 @ 1×</span>)</span>
          <div class="zoom-controls">
            <button class="zoom-btn active" id="zoom1" onclick="setZoom(1)">1×</button>
            <button class="zoom-btn" id="zoom2" onclick="setZoom(2)">2×</button>
            <button class="zoom-btn" id="zoom4" onclick="setZoom(4)">4×</button>
          </div>
          <button onclick="downloadImage()">Download PNG</button>
        </div>
        <div class="canvas-wrapper">
          <canvas id="imageCanvas" width="210" height="210"></canvas>
        </div>
        <div class="encoding-info" id="imageInfo">Unsigned: byte 0=black, 255=white</div>
      </div>

      <div class="preview-section">
        <div class="preview-label">
          <span>Audio Preview (<span id="audioDuration">1s</span> @ 44.1kHz 8-bit)</span>
        </div>
        <div class="waveform-container">
          <canvas id="waveformCanvas"></canvas>
        </div>
        <div class="encoding-info" id="audioInfo">Unsigned: 128=silence, 0/255=peaks</div>
        <div class="audio-controls">
          <button class="play-btn" id="playBtn" onclick="toggleAudio()">▶ Play</button>
          <button class="play-btn" id="playSelBtn" onclick="playSelection()" style="background:#cc00cc">▶ Selection</button>
          <button onclick="downloadAudio()">Download WAV</button>
        </div>
      </div>
    </div>
  </div>

  <div class="footer">
    <a href="https://ernestopena.com" target="_blank">ernestopena.com</a>
  </div>

  <script>
    const editor = document.getElementById('editor');
    const hexEditor = document.getElementById('hexEditor');
    const imageCanvas = document.getElementById('imageCanvas');
    const waveformCanvas = document.getElementById('waveformCanvas');
    const imgCtx = imageCanvas.getContext('2d');
    const waveCtx = waveformCanvas.getContext('2d');

    let mode = 'gray';
    let maxChars = 44100;
    let currentTab = 'text';
    let currentZoom = 1;
    let audioCtx = null;
    let sourceNode = null;
    let isPlaying = false;
    let rawBytes = new Uint8Array(0);
    let updatingFrom = null;
    let selection = { start: 0, end: 0 };

    function setMode(m) {
      mode = m;
      maxChars = m === 'gray' ? 44100 : 132300;
      document.getElementById('grayBtn').classList.toggle('active', m === 'gray');
      document.getElementById('rgbBtn').classList.toggle('active', m === 'rgb');
      document.getElementById('interleavingSelect').classList.toggle('hidden', m === 'gray');
      document.getElementById('maxCount').textContent = maxChars.toLocaleString();
      document.getElementById('audioDuration').textContent = m === 'gray' ? '1s' : '3s';
      if (rawBytes.length > maxChars) {
        rawBytes = rawBytes.slice(0, maxChars);
        syncFromBytes();
      }
      updatePreview();
    }

    function setZoom(z) {
      currentZoom = z;
      document.querySelectorAll('.zoom-btn').forEach(b => b.classList.remove('active'));
      document.getElementById('zoom' + z).classList.add('active');
      const size = 210 * z;
      imageCanvas.style.width = size + 'px';
      imageCanvas.style.height = size + 'px';
      document.getElementById('imageDims').textContent = `210×210 @ ${z}×`;
    }

    function switchTab(tab) {
      currentTab = tab;
      document.getElementById('textTab').classList.toggle('active', tab === 'text');
      document.getElementById('hexTab').classList.toggle('active', tab === 'hex');
      editor.classList.toggle('hidden', tab !== 'text');
      hexEditor.classList.toggle('hidden', tab !== 'hex');
    }

    function textToBytes(text) {
      const bytes = new Uint8Array(text.length);
      for (let i = 0; i < text.length; i++) bytes[i] = text.charCodeAt(i) & 0xFF;
      return bytes;
    }

    function bytesToText(bytes) {
      let t = '';
      for (let i = 0; i < bytes.length; i++) t += String.fromCharCode(bytes[i]);
      return t;
    }

    function bytesToHex(bytes) {
      let hex = '';
      for (let i = 0; i < bytes.length; i++) {
        hex += bytes[i].toString(16).padStart(2, '0').toUpperCase();
        if ((i + 1) % 16 === 0) hex += '\n';
        else if (i < bytes.length - 1) hex += ' ';
      }
      return hex;
    }

    function hexToBytes(hex) {
      const clean = hex.replace(/[^0-9A-Fa-f]/g, '');
      const bytes = new Uint8Array(Math.floor(clean.length / 2));
      for (let i = 0; i < bytes.length; i++) bytes[i] = parseInt(clean.substr(i * 2, 2), 16);
      return bytes;
    }

    function syncFromBytes() {
      if (updatingFrom === 'text') {
        hexEditor.value = bytesToHex(rawBytes);
      } else if (updatingFrom === 'hex') {
        editor.value = bytesToText(rawBytes);
      } else {
        editor.value = bytesToText(rawBytes);
        hexEditor.value = bytesToHex(rawBytes);
      }
    }

    function getBytes() {
      const padded = new Uint8Array(maxChars);
      padded.set(rawBytes.slice(0, maxChars));
      return padded;
    }

    function handleTextInput() {
      updatingFrom = 'text';
      let text = editor.value;
      if (text.length > maxChars) {
        text = text.substring(0, maxChars);
        editor.value = text;
      }
      rawBytes = textToBytes(text);
      syncFromBytes();
      updatingFrom = null;
      updatePreview();
    }

    function handleHexInput() {
      updatingFrom = 'hex';
      let bytes = hexToBytes(hexEditor.value);
      if (bytes.length > maxChars) bytes = bytes.slice(0, maxChars);
      rawBytes = bytes;
      syncFromBytes();
      updatingFrom = null;
      updatePreview();
    }

    function handleSelection() {
      let start, end;
      if (currentTab === 'text') {
        start = editor.selectionStart;
        end = editor.selectionEnd;
      } else {
        const hexStart = hexEditor.selectionStart;
        const hexEnd = hexEditor.selectionEnd;
        const beforeStart = hexEditor.value.substring(0, hexStart).replace(/[^0-9A-Fa-f]/g, '');
        const beforeEnd = hexEditor.value.substring(0, hexEnd).replace(/[^0-9A-Fa-f]/g, '');
        start = Math.floor(beforeStart.length / 2);
        end = Math.floor(beforeEnd.length / 2);
      }
      
      selection = { start: Math.min(start, end), end: Math.max(start, end) };
      updateSelectionInfo();
      updatePreview();
    }

    function updateSelectionInfo() {
      const info = document.getElementById('selectionInfo');
      if (selection.start === selection.end) {
        info.textContent = '';
        return;
      }
      const len = selection.end - selection.start;
      const startPx = Math.floor(selection.start / (mode === 'rgb' ? 3 : 1));
      const endPx = Math.ceil(selection.end / (mode === 'rgb' ? 3 : 1));
      const startTime = (selection.start / 44100).toFixed(4);
      const endTime = (selection.end / 44100).toFixed(4);
      info.textContent = `Selected: bytes ${selection.start}–${selection.end} (${len}) | pixels ${startPx}–${endPx} | audio ${startTime}s–${endTime}s`;
    }

    function fillRandom() {
      rawBytes = new Uint8Array(maxChars);
      for (let i = 0; i < maxChars; i++) rawBytes[i] = Math.floor(Math.random() * 256);
      syncFromBytes();
      updatePreview();
    }

    editor.addEventListener('input', handleTextInput);
    hexEditor.addEventListener('input', handleHexInput);
    editor.addEventListener('select', handleSelection);
    editor.addEventListener('click', handleSelection);
    editor.addEventListener('keyup', handleSelection);
    hexEditor.addEventListener('select', handleSelection);
    hexEditor.addEventListener('click', handleSelection);
    hexEditor.addEventListener('keyup', handleSelection);

    editor.addEventListener('paste', function(e) {
      e.preventDefault();
      const paste = (e.clipboardData || window.clipboardData).getData('text');
      const start = this.selectionStart;
      const end = this.selectionEnd;
      const before = this.value.substring(0, start);
      const after = this.value.substring(end);
      const available = maxChars - (this.value.length - (end - start));
      const truncated = paste.substring(0, Math.max(0, available));
      this.value = before + truncated + after;
      this.selectionStart = this.selectionEnd = start + truncated.length;
      handleTextInput();
    });

    function updateImage() {
      const bytes = getBytes();
      const encoding = document.getElementById('encodingSelect').value;
      const interleaving = document.getElementById('interleavingSelect').value;
      const imgData = imgCtx.createImageData(210, 210);

      if (mode === 'gray') {
        for (let i = 0; i < 44100; i++) {
          let val = bytes[i];
          if (encoding === 'signed') val = ((val < 128 ? val : val - 256) + 128);
          const idx = i * 4;
          imgData.data[idx] = val;
          imgData.data[idx + 1] = val;
          imgData.data[idx + 2] = val;
          imgData.data[idx + 3] = 255;
        }
        document.getElementById('imageInfo').textContent = encoding === 'unsigned'
          ? 'Unsigned: byte 0=black, 255=white'
          : 'Signed: -128→0 (black), 0→128 (gray), 127→255 (white)';
      } else {
        for (let i = 0; i < 44100; i++) {
          let r, g, b;
          if (interleaving === 'interleaved') {
            r = bytes[i * 3] || 0;
            g = bytes[i * 3 + 1] || 0;
            b = bytes[i * 3 + 2] || 0;
          } else {
            r = bytes[i] || 0;
            g = bytes[44100 + i] || 0;
            b = bytes[88200 + i] || 0;
          }
          if (encoding === 'signed') {
            r = ((r < 128 ? r : r - 256) + 128);
            g = ((g < 128 ? g : g - 256) + 128);
            b = ((b < 128 ? b : b - 256) + 128);
          }
          const idx = i * 4;
          imgData.data[idx] = r;
          imgData.data[idx + 1] = g;
          imgData.data[idx + 2] = b;
          imgData.data[idx + 3] = 255;
        }
        document.getElementById('imageInfo').textContent = encoding === 'unsigned'
          ? `Unsigned RGB (${interleaving}): 0=none, 255=full per channel`
          : `Signed RGB (${interleaving}): -128→0, 127→255 per channel`;
      }
      imgCtx.putImageData(imgData, 0, 0);

      // Draw selection overlay
      if (selection.start !== selection.end) {
        imgCtx.fillStyle = 'rgba(255, 0, 255, 0.4)';
        const interl = document.getElementById('interleavingSelect').value;
        
        if (mode === 'gray') {
          for (let i = selection.start; i < selection.end && i < 44100; i++) {
            const x = i % 210;
            const y = Math.floor(i / 210);
            imgCtx.fillRect(x, y, 1, 1);
          }
        } else if (interl === 'interleaved') {
          const startPx = Math.floor(selection.start / 3);
          const endPx = Math.ceil(selection.end / 3);
          for (let i = startPx; i < endPx && i < 44100; i++) {
            const x = i % 210;
            const y = Math.floor(i / 210);
            imgCtx.fillRect(x, y, 1, 1);
          }
        } else {
          // Planar: highlight R, G, B regions separately
          for (let i = selection.start; i < selection.end && i < 132300; i++) {
            let px;
            if (i < 44100) px = i;
            else if (i < 88200) px = i - 44100;
            else px = i - 88200;
            const x = px % 210;
            const y = Math.floor(px / 210);
            imgCtx.fillRect(x, y, 1, 1);
          }
        }
      }
    }

    function updateWaveform() {
      const bytes = getBytes();
      const encoding = document.getElementById('encodingSelect').value;
      const w = waveformCanvas.width = waveformCanvas.offsetWidth * 2;
      const h = waveformCanvas.height = 200;
      const samples = mode === 'gray' ? 44100 : 132300;

      waveCtx.fillStyle = '#fff';
      waveCtx.fillRect(0, 0, w, h);

      // Draw selection highlight
      if (selection.start !== selection.end) {
        const startX = (selection.start / samples) * w;
        const endX = (selection.end / samples) * w;
        waveCtx.fillStyle = 'rgba(255, 0, 255, 0.2)';
        waveCtx.fillRect(startX, 0, endX - startX, h);
      }

      waveCtx.strokeStyle = '#eee';
      waveCtx.lineWidth = 1;
      waveCtx.beginPath();
      waveCtx.moveTo(0, h / 2);
      waveCtx.lineTo(w, h / 2);
      waveCtx.stroke();

      waveCtx.strokeStyle = '#FF00FF';
      waveCtx.lineWidth = 1.5;
      waveCtx.beginPath();

      for (let x = 0; x < w; x++) {
        const i = Math.floor(x * samples / w);
        let val = bytes[i] || (encoding === 'unsigned' ? 128 : 0);
        let normalized = encoding === 'unsigned' ? (val - 128) / 128 : (val < 128 ? val : val - 256) / 128;
        const y = h / 2 - normalized * (h / 2 - 10);
        x === 0 ? waveCtx.moveTo(x, y) : waveCtx.lineTo(x, y);
      }
      waveCtx.stroke();

      document.getElementById('audioInfo').textContent = encoding === 'unsigned'
        ? 'Unsigned: 128=silence, 0/255=peaks'
        : 'Signed: 0=silence, -128/127=peaks';
    }

    function updateStats() {
      const len = rawBytes.length;
      const pct = (len / maxChars) * 100;
      document.getElementById('progressFill').style.width = Math.min(pct, 100) + '%';
      document.getElementById('currentCount').textContent = len.toLocaleString();
      document.getElementById('remainingCount').textContent = (maxChars - len).toLocaleString() + ' remaining';
    }

    function updatePreview() {
      updateStats();
      updateImage();
      updateWaveform();
    }

    function toggleAudio() { isPlaying ? stopAudio() : playAudio(); }

    function playAudio() {
      const bytes = getBytes();
      const encoding = document.getElementById('encodingSelect').value;
      const sampleRate = 44100;
      const numSamples = mode === 'gray' ? 44100 : 132300;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate });
      const buffer = audioCtx.createBuffer(1, numSamples, sampleRate);
      const channel = buffer.getChannelData(0);

      for (let i = 0; i < numSamples; i++) {
        let val = bytes[i] || (encoding === 'unsigned' ? 128 : 0);
        channel[i] = encoding === 'unsigned' ? (val - 128) / 128 : (val < 128 ? val : val - 256) / 128;
      }

      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = buffer;
      sourceNode.connect(audioCtx.destination);
      sourceNode.onended = stopAudio;
      sourceNode.start();
      isPlaying = true;
      document.getElementById('playBtn').textContent = '◼ Stop';
    }

    function stopAudio() {
      if (sourceNode) { sourceNode.stop(); sourceNode.disconnect(); }
      if (audioCtx) audioCtx.close();
      isPlaying = false;
      document.getElementById('playBtn').textContent = '▶ Play';
      document.getElementById('playSelBtn').textContent = '▶ Selection';
    }

    function playSelection() {
      if (isPlaying) { stopAudio(); return; }
      if (selection.start === selection.end) { alert('No selection'); return; }
      
      const bytes = getBytes();
      const encoding = document.getElementById('encodingSelect').value;
      const sampleRate = 44100;
      const numSamples = selection.end - selection.start;

      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate });
      const buffer = audioCtx.createBuffer(1, numSamples, sampleRate);
      const channel = buffer.getChannelData(0);

      for (let i = 0; i < numSamples; i++) {
        let val = bytes[selection.start + i] || (encoding === 'unsigned' ? 128 : 0);
        channel[i] = encoding === 'unsigned' ? (val - 128) / 128 : (val < 128 ? val : val - 256) / 128;
      }

      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = buffer;
      sourceNode.connect(audioCtx.destination);
      sourceNode.onended = stopAudio;
      sourceNode.start();
      isPlaying = true;
      document.getElementById('playSelBtn').textContent = '◼ Stop';
    }

    function downloadFile(ext) {
      if (!rawBytes.length) return alert('Nothing to download');
      const blob = ext === 'raw'
        ? new Blob([rawBytes], { type: 'application/octet-stream' })
        : new Blob([bytesToText(rawBytes)], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'data-' + Date.now() + '.' + ext;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function downloadImage() {
      const a = document.createElement('a');
      a.href = imageCanvas.toDataURL('image/png');
      a.download = 'image-' + Date.now() + '.png';
      a.click();
    }

    function downloadAudio() {
      const bytes = getBytes();
      const encoding = document.getElementById('encodingSelect').value;
      const numSamples = mode === 'gray' ? 44100 : 132300;
      const sampleRate = 44100;

      const wavBuffer = new ArrayBuffer(44 + numSamples);
      const view = new DataView(wavBuffer);
      const writeStr = (o, s) => { for (let i = 0; i < s.length; i++) view.setUint8(o + i, s.charCodeAt(i)); };

      writeStr(0, 'RIFF');
      view.setUint32(4, 36 + numSamples, true);
      writeStr(8, 'WAVE');
      writeStr(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate, true);
      view.setUint16(32, 1, true);
      view.setUint16(34, 8, true);
      writeStr(36, 'data');
      view.setUint32(40, numSamples, true);

      for (let i = 0; i < numSamples; i++) {
        let val = bytes[i] || (encoding === 'unsigned' ? 128 : 0);
        if (encoding === 'signed') val = ((val < 128 ? val : val - 256) + 128);
        view.setUint8(44 + i, val);
      }

      const blob = new Blob([wavBuffer], { type: 'audio/wav' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'audio-' + Date.now() + '.wav';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const warning = document.getElementById('uploadWarning');
      const reader = new FileReader();

      reader.onload = function(e) {
        let bytes = new Uint8Array(e.target.result);
        const originalLength = bytes.length;

        if (bytes.length > maxChars) {
          bytes = bytes.slice(0, maxChars);
          warning.textContent = `File truncated: ${originalLength.toLocaleString()} bytes → ${maxChars.toLocaleString()} bytes (limit reached)`;
          warning.classList.add('visible');
        } else {
          warning.textContent = `Loaded ${bytes.length.toLocaleString()} bytes from ${file.name}`;
          warning.classList.add('visible');
        }

        rawBytes = bytes;
        syncFromBytes();
        updatePreview();
        setTimeout(() => warning.classList.remove('visible'), 5000);
      };

      reader.readAsArrayBuffer(file);
      event.target.value = '';
    }

    updatePreview();
  </script>
</body>
</html>
