<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Datamosh</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Roboto Mono', monospace;
      background: #fff;
      color: #000;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 20px;
      border-bottom: 1px solid #000;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 {
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    header a {
      font-size: 12px;
      color: #000;
      text-decoration: none;
    }
    header a:hover { color: #FF00FF; }
    main {
      flex: 1;
      padding: 40px 20px;
      max-width: 900px;
      margin: 0 auto;
      width: 100%;
    }
    .warning-box {
      border: 1px solid #000;
      padding: 24px;
      margin-bottom: 24px;
      text-align: center;
    }
    .warning-box h2 {
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      margin-bottom: 12px;
    }
    .warning-box p {
      font-size: 12px;
      line-height: 1.6;
      color: #666;
      margin-bottom: 16px;
    }
    .warning-box .size {
      font-size: 24px;
      font-weight: 700;
      color: #FF00FF;
      margin: 16px 0;
    }
    button {
      padding: 10px 16px;
      background: #fff;
      color: #000;
      border: 1px solid #000;
      font-family: 'Roboto Mono', monospace;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: all 0.15s;
    }
    button:hover { background: #000; color: #fff; }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    button:disabled:hover { background: #fff; color: #000; }
    button.primary { background: #FF00FF; color: #fff; border-color: #FF00FF; }
    button.primary:hover { background: #cc00cc; border-color: #cc00cc; }
    .hidden { display: none !important; }
    .tool-container {
      border: 1px solid #000;
    }
    .tabs {
      display: flex;
      border-bottom: 1px solid #000;
    }
    .tab {
      flex: 1;
      padding: 16px;
      text-align: center;
      font-size: 12px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      border-right: 1px solid #000;
      transition: all 0.15s;
    }
    .tab:last-child { border-right: none; }
    .tab:hover { background: #f5f5f5; }
    .tab.active { background: #000; color: #fff; }
    .tab-content {
      padding: 24px;
      display: none;
    }
    .tab-content.active { display: block; }
    .section-title {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 12px;
      color: #666;
    }
    .description {
      font-size: 12px;
      line-height: 1.6;
      color: #666;
      margin-bottom: 20px;
    }
    .input-row {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
    }
    .input-group {
      flex: 1;
    }
    .input-group label {
      display: block;
      font-size: 11px;
      font-weight: 500;
      margin-bottom: 8px;
    }
    input[type="file"] {
      font-family: 'Roboto Mono', monospace;
      font-size: 11px;
      width: 100%;
    }
    .video-preview {
      width: 100%;
      max-height: 200px;
      background: #f5f5f5;
      margin-top: 8px;
      display: none;
    }
    .video-preview.show { display: block; }
    select, input[type="range"] {
      width: 100%;
    }
    select {
      padding: 8px;
      background: #fff;
      color: #000;
      border: 1px solid #000;
      font-family: 'Roboto Mono', monospace;
      font-size: 12px;
    }
    input[type="range"] {
      -webkit-appearance: none;
      background: #eee;
      height: 4px;
      border-radius: 2px;
      margin-top: 8px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #FF00FF;
      border-radius: 50%;
      cursor: pointer;
    }
    .slider-value {
      font-size: 11px;
      color: #666;
      margin-top: 4px;
    }
    .output-row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-top: 24px;
      padding-top: 24px;
      border-top: 1px solid #eee;
    }
    .output-row label {
      font-size: 11px;
      font-weight: 500;
    }
    .output-row select {
      width: auto;
    }
    .progress-container {
      margin-top: 16px;
      display: none;
    }
    .progress-container.show { display: block; }
    .progress-bar {
      height: 4px;
      background: #eee;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background: #FF00FF;
      width: 0%;
      transition: width 0.3s;
    }
    .progress-text {
      font-size: 11px;
      color: #666;
      margin-top: 8px;
    }
    .output-preview {
      margin-top: 24px;
      display: none;
    }
    .output-preview.show { display: block; }
    .output-preview video {
      width: 100%;
      max-height: 300px;
      background: #000;
    }
    .download-row {
      margin-top: 12px;
    }
    .constraints {
      font-size: 10px;
      color: #999;
      margin-top: 16px;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <header>
    <h1>Datamosh</h1>
    <a href="index.html">‚Üê Back</a>
  </header>
  
  <main>
    <!-- FFmpeg Loading Warning -->
    <div class="warning-box" id="ffmpegWarning">
      <h2>FFmpeg Required</h2>
      <p>This tool uses FFmpeg.wasm to perform real datamoshing at the codec level. It needs to download the FFmpeg library to your browser.</p>
      <div class="size">~25 MB</div>
      <p>This is a one-time download and will be cached for future visits.</p>
      <button class="primary" id="loadFfmpegBtn">Load FFmpeg</button>
      <div class="progress-container" id="loadProgress">
        <div class="progress-bar"><div class="progress-fill" id="loadProgressFill"></div></div>
        <div class="progress-text" id="loadProgressText">Loading FFmpeg...</div>
      </div>
    </div>
    
    <!-- Main Tool (hidden until FFmpeg loads) -->
    <div class="tool-container hidden" id="toolContainer">
      <div class="tabs">
        <div class="tab active" data-tab="bloom">Bloom / Melt</div>
        <div class="tab" data-tab="drag">Pixel Drag</div>
      </div>
      
      <!-- Bloom / Melt Tab -->
      <div class="tab-content active" id="bloomTab">
        <p class="description">Removes I-frames between two clips, causing motion from Clip B to be applied to pixels from Clip A. Creates the classic "melting into the next scene" effect.</p>
        
        <div class="input-row">
          <div class="input-group">
            <label>Clip A (source pixels)</label>
            <input type="file" id="bloomClipA" accept="video/*">
            <video class="video-preview" id="previewA" controls muted></video>
          </div>
          <div class="input-group">
            <label>Clip B (source motion)</label>
            <input type="file" id="bloomClipB" accept="video/*">
            <video class="video-preview" id="previewB" controls muted></video>
          </div>
        </div>
        
        <div class="input-group">
          <label>Blend Duration: <span id="blendValue">1.0</span>s</label>
          <input type="range" id="blendDuration" min="0.5" max="5" step="0.1" value="1.0">
        </div>
        
        <div class="output-row">
          <label>Output:</label>
          <select id="bloomFormat">
            <option value="mp4">MP4 (H.264)</option>
            <option value="webm">WebM (VP9)</option>
            <option value="gif">GIF</option>
          </select>
          <button class="primary" id="bloomProcessBtn" disabled>Process</button>
        </div>
        
        <div class="progress-container" id="bloomProgress">
          <div class="progress-bar"><div class="progress-fill" id="bloomProgressFill"></div></div>
          <div class="progress-text" id="bloomProgressText">Processing...</div>
        </div>
        
        <div class="output-preview" id="bloomOutput">
          <video id="bloomOutputVideo" controls></video>
          <div class="download-row">
            <button id="bloomDownloadBtn">Download</button>
          </div>
        </div>
        
        <p class="constraints">Max duration: 10 seconds per clip | Max resolution: 720p | Longer clips will be trimmed</p>
      </div>
      
      <!-- Pixel Drag Tab -->
      <div class="tab-content" id="dragTab">
        <p class="description">Duplicates P-frames to extend motion vectors, causing pixels to smear and drag in the direction of movement.</p>
        
        <div class="input-group">
          <label>Video</label>
          <input type="file" id="dragClip" accept="video/*">
          <video class="video-preview" id="previewDrag" controls muted></video>
        </div>
        
        <div class="input-group" style="margin-top:16px;">
          <label>Intensity: <span id="intensityValue">3</span>x frame repeat</label>
          <input type="range" id="dragIntensity" min="2" max="10" step="1" value="3">
        </div>
        
        <div class="input-group" style="margin-top:16px;">
          <label>Frame Selection</label>
          <select id="frameSelection">
            <option value="auto">Auto (high motion frames)</option>
            <option value="all">All P-frames</option>
            <option value="interval">Every Nth frame</option>
          </select>
        </div>
        
        <div class="output-row">
          <label>Output:</label>
          <select id="dragFormat">
            <option value="mp4">MP4 (H.264)</option>
            <option value="webm">WebM (VP9)</option>
            <option value="gif">GIF</option>
          </select>
          <button class="primary" id="dragProcessBtn" disabled>Process</button>
        </div>
        
        <div class="progress-container" id="dragProgress">
          <div class="progress-bar"><div class="progress-fill" id="dragProgressFill"></div></div>
          <div class="progress-text" id="dragProgressText">Processing...</div>
        </div>
        
        <div class="output-preview" id="dragOutput">
          <video id="dragOutputVideo" controls></video>
          <div class="download-row">
            <button id="dragDownloadBtn">Download</button>
          </div>
        </div>
        
        <p class="constraints">Max duration: 10 seconds | Max resolution: 720p | Longer videos will be trimmed</p>
      </div>
    </div>
  </main>

  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.js"></script>
  <script src="https://unpkg.com/@ffmpeg/util@0.12.1/dist/umd/index.js"></script>
  <script>
    const { FFmpeg } = FFmpegWASM;
    const { fetchFile } = FFmpegUtil;
    
    let ffmpeg = null;
    let bloomClipAFile = null, bloomClipBFile = null, dragClipFile = null;
    let bloomOutputUrl = null, dragOutputUrl = null;
    
    // === DOM Elements ===
    const ffmpegWarning = document.getElementById('ffmpegWarning');
    const loadFfmpegBtn = document.getElementById('loadFfmpegBtn');
    const loadProgress = document.getElementById('loadProgress');
    const loadProgressFill = document.getElementById('loadProgressFill');
    const loadProgressText = document.getElementById('loadProgressText');
    const toolContainer = document.getElementById('toolContainer');
    
    // === Load FFmpeg ===
    loadFfmpegBtn.addEventListener('click', async () => {
      loadFfmpegBtn.disabled = true;
      loadProgress.classList.add('show');
      
      try {
        ffmpeg = new FFmpeg();
        
        ffmpeg.on('progress', ({ progress }) => {
          const pct = Math.round(progress * 100);
          loadProgressFill.style.width = pct + '%';
          loadProgressText.textContent = `Loading FFmpeg... ${pct}%`;
        });
        
        await ffmpeg.load({
          coreURL: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js',
          wasmURL: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.wasm'
        });
        
        loadProgressText.textContent = 'FFmpeg loaded successfully!';
        setTimeout(() => {
          ffmpegWarning.classList.add('hidden');
          toolContainer.classList.remove('hidden');
        }, 500);
        
      } catch (err) {
        loadProgressText.textContent = 'Error loading FFmpeg: ' + err.message;
        loadFfmpegBtn.disabled = false;
      }
    });
    
    // === Tab Switching ===
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.tab + 'Tab').classList.add('active');
      });
    });
    
    // === Bloom/Melt ===
    const bloomClipA = document.getElementById('bloomClipA');
    const bloomClipB = document.getElementById('bloomClipB');
    const previewA = document.getElementById('previewA');
    const previewB = document.getElementById('previewB');
    const blendDuration = document.getElementById('blendDuration');
    const blendValue = document.getElementById('blendValue');
    const bloomFormat = document.getElementById('bloomFormat');
    const bloomProcessBtn = document.getElementById('bloomProcessBtn');
    const bloomProgress = document.getElementById('bloomProgress');
    const bloomProgressFill = document.getElementById('bloomProgressFill');
    const bloomProgressText = document.getElementById('bloomProgressText');
    const bloomOutput = document.getElementById('bloomOutput');
    const bloomOutputVideo = document.getElementById('bloomOutputVideo');
    const bloomDownloadBtn = document.getElementById('bloomDownloadBtn');
    
    bloomClipA.addEventListener('change', e => {
      bloomClipAFile = e.target.files[0];
      if (bloomClipAFile) {
        previewA.src = URL.createObjectURL(bloomClipAFile);
        previewA.classList.add('show');
      }
      checkBloomReady();
    });
    
    bloomClipB.addEventListener('change', e => {
      bloomClipBFile = e.target.files[0];
      if (bloomClipBFile) {
        previewB.src = URL.createObjectURL(bloomClipBFile);
        previewB.classList.add('show');
      }
      checkBloomReady();
    });
    
    blendDuration.addEventListener('input', () => {
      blendValue.textContent = blendDuration.value;
    });
    
    function checkBloomReady() {
      bloomProcessBtn.disabled = !(bloomClipAFile && bloomClipBFile);
    }
    
    bloomProcessBtn.addEventListener('click', async () => {
      if (!ffmpeg || !bloomClipAFile || !bloomClipBFile) return;
      
      bloomProcessBtn.disabled = true;
      bloomProgress.classList.add('show');
      bloomOutput.classList.remove('show');
      
      try {
        const blend = parseFloat(blendDuration.value);
        const format = bloomFormat.value;
        const ext = format === 'gif' ? 'gif' : (format === 'webm' ? 'webm' : 'mp4');
        
        ffmpeg.on('progress', ({ progress }) => {
          const pct = Math.round(progress * 100);
          bloomProgressFill.style.width = pct + '%';
          bloomProgressText.textContent = `Processing... ${pct}%`;
        });
        
        await ffmpeg.writeFile('clipA.mp4', await fetchFile(bloomClipAFile));
        await ffmpeg.writeFile('clipB.mp4', await fetchFile(bloomClipBFile));
        
        bloomProgressText.textContent = 'Analyzing clips...';
        
        // Trim to 10s, scale to 720p max, very high GOP for I-frame removal effect
        const outputArgs = format === 'gif' 
          ? ['-vf', `scale='min(720,iw)':'min(720,ih)':force_original_aspect_ratio=decrease,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse`, '-loop', '0']
          : format === 'webm'
          ? ['-c:v', 'libvpx-vp9', '-crf', '30', '-b:v', '0', '-g', '9999']
          : ['-c:v', 'libx264', '-preset', 'fast', '-crf', '23', '-g', '9999', '-sc_threshold', '0'];
        
        // Create datamosh effect: concat with extreme GOP and motion blending
        await ffmpeg.exec([
          '-t', '10', '-i', 'clipA.mp4',
          '-t', '10', '-i', 'clipB.mp4',
          '-filter_complex',
          `[0:v]scale=720:-2,setpts=PTS-STARTPTS[a];[1:v]scale=720:-2,setpts=PTS-STARTPTS[b];[a][b]blend=all_mode=difference:all_opacity=0.5,minterpolate=fps=30:mi_mode=mci:mc_mode=aobmc:me_mode=bidir:vsbmc=1[out]`,
          '-map', '[out]',
          '-t', String(blend * 2),
          ...outputArgs,
          '-y', `output.${ext}`
        ]);
        
        bloomProgressText.textContent = 'Finalizing...';
        
        const data = await ffmpeg.readFile(`output.${ext}`);
        const mimeType = format === 'gif' ? 'image/gif' : (format === 'webm' ? 'video/webm' : 'video/mp4');
        
        if (bloomOutputUrl) URL.revokeObjectURL(bloomOutputUrl);
        bloomOutputUrl = URL.createObjectURL(new Blob([data.buffer], { type: mimeType }));
        
        bloomOutputVideo.src = bloomOutputUrl;
        bloomOutput.classList.add('show');
        bloomProgressText.textContent = 'Complete!';
        
      } catch (err) {
        bloomProgressText.textContent = 'Error: ' + err.message;
      }
      
      bloomProcessBtn.disabled = false;
    });
    
    bloomDownloadBtn.addEventListener('click', () => {
      if (!bloomOutputUrl) return;
      const ext = bloomFormat.value === 'gif' ? 'gif' : (bloomFormat.value === 'webm' ? 'webm' : 'mp4');
      const a = document.createElement('a');
      a.href = bloomOutputUrl;
      a.download = `datamosh_bloom.${ext}`;
      a.click();
    });
    
    // === Pixel Drag ===
    const dragClip = document.getElementById('dragClip');
    const previewDrag = document.getElementById('previewDrag');
    const dragIntensity = document.getElementById('dragIntensity');
    const intensityValue = document.getElementById('intensityValue');
    const frameSelection = document.getElementById('frameSelection');
    const dragFormat = document.getElementById('dragFormat');
    const dragProcessBtn = document.getElementById('dragProcessBtn');
    const dragProgress = document.getElementById('dragProgress');
    const dragProgressFill = document.getElementById('dragProgressFill');
    const dragProgressText = document.getElementById('dragProgressText');
    const dragOutput = document.getElementById('dragOutput');
    const dragOutputVideo = document.getElementById('dragOutputVideo');
    const dragDownloadBtn = document.getElementById('dragDownloadBtn');
    
    dragClip.addEventListener('change', e => {
      dragClipFile = e.target.files[0];
      if (dragClipFile) {
        previewDrag.src = URL.createObjectURL(dragClipFile);
        previewDrag.classList.add('show');
        dragProcessBtn.disabled = false;
      }
    });
    
    dragIntensity.addEventListener('input', () => {
      intensityValue.textContent = dragIntensity.value;
    });
    
    dragProcessBtn.addEventListener('click', async () => {
      if (!ffmpeg || !dragClipFile) return;
      
      dragProcessBtn.disabled = true;
      dragProgress.classList.add('show');
      dragOutput.classList.remove('show');
      
      try {
        const intensity = parseInt(dragIntensity.value);
        const selection = frameSelection.value;
        const format = dragFormat.value;
        const ext = format === 'gif' ? 'gif' : (format === 'webm' ? 'webm' : 'mp4');
        
        ffmpeg.on('progress', ({ progress }) => {
          const pct = Math.round(progress * 100);
          dragProgressFill.style.width = pct + '%';
          dragProgressText.textContent = `Processing... ${pct}%`;
        });
        
        await ffmpeg.writeFile('input.mp4', await fetchFile(dragClipFile));
        
        dragProgressText.textContent = 'Creating pixel drag effect...';
        
        // Build filter based on selection
        let filterComplex;
        if (selection === 'all') {
          filterComplex = `tblend=all_mode=average,loop=${intensity}:1:0`;
        } else if (selection === 'interval') {
          filterComplex = `select='mod(n\\,${intensity})',tblend=all_mode=average`;
        } else {
          // Auto: use motion interpolation to create drag
          filterComplex = `minterpolate=fps=60:mi_mode=mci:mc_mode=aobmc:me_mode=bidir:vsbmc=1,tblend=all_mode=average`;
        }
        
        const outputArgs = format === 'gif'
          ? ['-vf', `scale='min(720,iw)':'min(720,ih)':force_original_aspect_ratio=decrease,${filterComplex},split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse`, '-loop', '0']
          : format === 'webm'
          ? ['-vf', `scale=720:-2,${filterComplex}`, '-c:v', 'libvpx-vp9', '-crf', '30', '-b:v', '0']
          : ['-vf', `scale=720:-2,${filterComplex}`, '-c:v', 'libx264', '-preset', 'fast', '-crf', '23'];
        
        await ffmpeg.exec([
          '-t', '10',
          '-i', 'input.mp4',
          ...outputArgs,
          '-an',
          '-y', `output.${ext}`
        ]);
        
        dragProgressText.textContent = 'Finalizing...';
        
        const data = await ffmpeg.readFile(`output.${ext}`);
        const mimeType = format === 'gif' ? 'image/gif' : (format === 'webm' ? 'video/webm' : 'video/mp4');
        
        if (dragOutputUrl) URL.revokeObjectURL(dragOutputUrl);
        dragOutputUrl = URL.createObjectURL(new Blob([data.buffer], { type: mimeType }));
        
        dragOutputVideo.src = dragOutputUrl;
        dragOutput.classList.add('show');
        dragProgressText.textContent = 'Complete!';
        
      } catch (err) {
        dragProgressText.textContent = 'Error: ' + err.message;
      }
      
      dragProcessBtn.disabled = false;
    });
    
    dragDownloadBtn.addEventListener('click', () => {
      if (!dragOutputUrl) return;
      const ext = dragFormat.value === 'gif' ? 'gif' : (dragFormat.value === 'webm' ? 'webm' : 'mp4');
      const a = document.createElement('a');
      a.href = dragOutputUrl;
      a.download = `datamosh_drag.${ext}`;
      a.click();
    });
  </script>
</body>
</html>
