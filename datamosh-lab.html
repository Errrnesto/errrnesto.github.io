<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DATAMOSH LAB | Frame Analysis & Effect Simulation</title>
  <meta name="author" content="Ernesto Peña">
  <meta name="description" content="Comprehensive tool for analysing video frame structure and simulating datamosh effects using motion vector estimation.">
  <meta name="citation_author" content="Peña, Ernesto">
  <meta name="citation_title" content="Datamosh Lab: A Glitch Pedagogy Tool">
  <meta name="citation_date" content="2025">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
     <script async src="https://www.googletagmanager.com/gtag/js?id=G-8XQLL5N022"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-8XQLL5N022');
  </script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #0a0a0a; color: #e0e0e0; font-family: 'Roboto Mono', monospace; padding: 16px; line-height: 1.5; }
    
    header { margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid #222; }
    h1 { color: #e91e8c; font-size: 1.3rem; margin-bottom: 2px; }
    .subtitle { color: #666; font-size: 0.72rem; }
    
    .upload-area { text-align: center; padding: 28px; border: 2px dashed #333; border-radius: 8px; margin-bottom: 16px; transition: all 0.3s; }
    .upload-area:hover, .upload-area.dragover { border-color: #e91e8c; background: rgba(233,30,140,0.03); }
    .upload-btn { display: inline-block; padding: 11px 22px; background: #1a1a1a; border: 2px solid #e91e8c; border-radius: 4px; color: #e91e8c; cursor: pointer; font-family: inherit; font-size: 0.8rem; }
    .upload-btn:hover { background: #e91e8c; color: #0a0a0a; }
    .upload-btn input { display: none; }
    
    .status-msg { margin-top: 12px; padding: 10px; background: #1a1a1a; border-radius: 4px; font-size: 0.75rem; display: inline-block; }
    .progress-bar { height: 4px; background: #333; border-radius: 2px; margin-top: 8px; overflow: hidden; width: 200px; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #e91e8c, #00bcd4); transition: width 0.2s; }
    
    .main-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 14px; }
    @media (max-width: 1150px) { .main-grid { grid-template-columns: 1fr 1fr; } }
    @media (max-width: 780px) { .main-grid { grid-template-columns: 1fr; } }
    
    .panel { background: #111; border: 1px solid #222; border-radius: 6px; padding: 12px; margin-bottom: 14px; }
    .panel-title { color: #e91e8c; font-size: 0.78rem; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 6px; }
    .panel-title .badge { font-size: 0.65rem; padding: 2px 6px; border-radius: 3px; }
    .badge.active { background: #e91e8c; color: #000; }
    .badge.inactive { background: #333; color: #888; }
    
    .video-wrap { position: relative; background: #000; border-radius: 4px; overflow: hidden; aspect-ratio: 16/9; }
    .video-wrap video, .video-wrap canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; }
    
    .ctrl-row { display: flex; gap: 5px; flex-wrap: wrap; margin-top: 8px; }
    .ctrl-btn { padding: 5px 9px; background: #1a1a1a; border: 1px solid #444; border-radius: 3px; color: #e0e0e0; cursor: pointer; font-family: inherit; font-size: 0.68rem; transition: all 0.15s; }
    .ctrl-btn:hover { border-color: #e91e8c; color: #e91e8c; }
    .ctrl-btn.active { background: #e91e8c; border-color: #e91e8c; color: #0a0a0a; }
    .ctrl-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    
    .slider-group { padding: 8px; background: #1a1a1a; border-radius: 4px; margin-top: 6px; }
    .slider-label { display: flex; justify-content: space-between; font-size: 0.68rem; margin-bottom: 4px; }
    .slider-label span:last-child { color: #e91e8c; }
    input[type="range"] { width: 100%; height: 3px; background: #333; border-radius: 2px; -webkit-appearance: none; margin-top: 2px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 11px; height: 11px; background: #e91e8c; border-radius: 50%; cursor: pointer; }
    
    .info-box { margin-top: 8px; padding: 8px; background: #1a1a2a; border-radius: 4px; font-size: 0.65rem; border-left: 2px solid #e91e8c; }
    .info-box strong { color: #e91e8c; }
    
    .timeline { height: 44px; background: #1a1a1a; border-radius: 4px; position: relative; cursor: pointer; overflow: hidden; }
    .timeline-bar { position: absolute; bottom: 0; min-width: 1px; }
    .timeline-bar.high { background: #e91e8c; }
    .timeline-bar.low { background: #00bcd4; opacity: 0.7; }
    .playhead { position: absolute; width: 2px; height: 100%; background: #fff; box-shadow: 0 0 6px #fff; z-index: 10; pointer-events: none; }
    .timeline-labels { display: flex; justify-content: space-between; font-size: 0.6rem; color: #666; margin-top: 3px; }
    
    .legend { display: flex; gap: 12px; font-size: 0.65rem; margin-top: 6px; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 4px; }
    .legend-dot { width: 8px; height: 8px; border-radius: 2px; }
    .legend-dot.high { background: #e91e8c; }
    .legend-dot.low { background: #00bcd4; }
    
    .stats-row { display: flex; gap: 8px; margin-top: 10px; }
    .stat-box { flex: 1; text-align: center; padding: 8px 4px; background: #1a1a1a; border-radius: 4px; }
    .stat-value { font-size: 1.1rem; font-weight: bold; }
    .stat-value.high { color: #e91e8c; }
    .stat-value.low { color: #00bcd4; }
    .stat-value.neutral { color: #8bc34a; }
    .stat-label { font-size: 0.58rem; color: #888; margin-top: 2px; }
    
    .meter { height: 14px; background: #0a0a0a; border-radius: 3px; overflow: hidden; position: relative; }
    .meter-fill { height: 100%; background: linear-gradient(90deg, #00bcd4, #e91e8c); transition: width 0.1s; }
    .meter-threshold { position: absolute; top: 0; height: 100%; width: 2px; background: rgba(255,255,255,0.5); }
    
    .frame-indicator { padding: 6px 10px; border-radius: 3px; text-align: center; font-weight: bold; font-size: 0.72rem; margin-top: 6px; }
    .frame-indicator.high { background: rgba(233,30,140,0.15); color: #e91e8c; border: 1px solid rgba(233,30,140,0.4); }
    .frame-indicator.low { background: rgba(0,188,212,0.15); color: #00bcd4; border: 1px solid rgba(0,188,212,0.4); }
    
    .tab-row { display: flex; gap: 3px; margin-bottom: 8px; border-bottom: 1px solid #333; padding-bottom: 6px; }
    .tab-btn { padding: 4px 10px; background: transparent; border: none; color: #888; cursor: pointer; font-family: inherit; font-size: 0.68rem; border-radius: 3px 3px 0 0; }
    .tab-btn:hover { color: #e0e0e0; }
    .tab-btn.active { background: #1a1a1a; color: #e91e8c; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    .structure-view { display: flex; flex-wrap: wrap; gap: 2px; padding: 8px; background: #0a0a0a; border-radius: 4px; max-height: 110px; overflow-y: auto; }
    .struct-block { width: 7px; height: 7px; border-radius: 1px; }
    .struct-block.high { background: #e91e8c; box-shadow: 0 0 3px #e91e8c; }
    .struct-block.low { background: #00bcd4; opacity: 0.6; }
    .struct-block.deleted { opacity: 0.15; }
    .struct-block.current { box-shadow: 0 0 0 1px #fff; }
    
    .gop-diagram { display: flex; gap: 2px; padding: 10px; background: #1a1a1a; border-radius: 4px; overflow-x: auto; align-items: flex-end; min-height: 90px; }
    .gop-frame { display: flex; flex-direction: column; align-items: center; min-width: 14px; }
    .gop-bar { width: 12px; border-radius: 2px 2px 0 0; transition: height 0.2s; }
    .gop-bar.high { background: #e91e8c; box-shadow: 0 0 4px #e91e8c; }
    .gop-bar.low { background: #00bcd4; opacity: 0.7; }
    .gop-label { font-size: 0.5rem; color: #666; margin-top: 2px; }
    
    .export-data { padding: 8px; background: #0a0a0a; border-radius: 4px; font-size: 0.6rem; max-height: 100px; overflow-y: auto; white-space: pre-wrap; word-break: break-all; }
    
    .vector-info { margin-top: 6px; font-size: 0.62rem; color: #888; }
    .vector-info span { color: #00ff88; }
    
    .hidden { display: none !important; }
    footer { margin-top: 24px; padding-top: 14px; border-top: 1px solid #222; font-size: 0.65rem; color: #666; text-align: center; }
    footer a { color: #e91e8c; text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <h1>Datamosh Lab</h1>
    <p class="subtitle">Frame structure analysis + motion vector visualization + bloom/pixel drag simulation</p>
  </header>

  <div class="upload-area" id="uploadArea">
    <label class="upload-btn"><input type="file" accept="video/*" id="fileInput">Choose Video</label>
    <span style="margin-left:10px;color:#666;font-size:0.72rem">or drag & drop</span>
    <div class="status-msg hidden" id="statusMsg">
      <span id="statusText">Analyzing...</span>
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    </div>
  </div>

  <div id="content" class="hidden">
    <div class="main-grid">
      <!-- COL 1: Original + Analysis -->
      <div>
        <div class="panel">
          <div class="panel-title"><span>Original Video</span><span id="timeDisplay" style="font-size:0.65rem;color:#888">0:00/0:00</span></div>
          <div class="video-wrap"><video id="video" muted playsinline></video></div>
          <div class="ctrl-row">
            <button class="ctrl-btn" id="playBtn">▶ Play</button>
            <button class="ctrl-btn" id="stepBackBtn">← Back</button>
            <button class="ctrl-btn" id="stepBtn">→ Step</button>
            <button class="ctrl-btn" id="resetBtn">↺ Reset</button>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Real-Time Analysis</div>
          <div class="slider-label"><span>Frame Change</span><span id="changePercent">0%</span></div>
          <div class="meter"><div class="meter-fill" id="changeMeter"></div><div class="meter-threshold" id="threshMarker" style="left:25%"></div></div>
          <div class="frame-indicator low" id="frameIndicator">Waiting...</div>
          <div class="slider-group">
            <div class="slider-label"><span>I-Frame Threshold</span><span id="threshVal">5%</span></div>
            <input type="range" id="threshSlider" min="1" max="20" value="5">
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Timeline</div>
          <div class="timeline" id="timeline"><div class="playhead" id="playhead"></div></div>
          <div class="timeline-labels"><span>0:00</span><span id="durLabel">0:00</span></div>
          <div class="legend">
            <div class="legend-item"><div class="legend-dot high"></div>I-candidate</div>
            <div class="legend-item"><div class="legend-dot low"></div>P-candidate</div>
          </div>
          <div class="stats-row">
            <div class="stat-box"><div class="stat-value high" id="highCount">0</div><div class="stat-label">I-candidates</div></div>
            <div class="stat-box"><div class="stat-value low" id="lowCount">0</div><div class="stat-label">P-candidates</div></div>
            <div class="stat-box"><div class="stat-value neutral" id="totalCount">0</div><div class="stat-label">Total</div></div>
          </div>
        </div>
      </div>

      <!-- COL 2: Motion Vectors -->
      <div>
        <div class="panel">
          <div class="panel-title">Motion Vector Field</div>
          <div class="video-wrap"><canvas id="motionCanvas"></canvas></div>
          <div class="vector-info"><span>→</span> Arrows show motion direction & magnitude per 16×16 block</div>
          <div class="info-box">
            <strong>What you see:</strong> This is what P-frames encode—motion vectors describing where each block moved. Datamoshing applies these vectors to the wrong pixels.
          </div>
        </div>
        
        <div class="panel">
          <div class="tab-row">
            <button class="tab-btn active" data-tab="structure">Structure</button>
            <button class="tab-btn" data-tab="gop">GOP</button>
            <button class="tab-btn" data-tab="export">Export</button>
          </div>
          <div class="tab-content active" id="tab-structure">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
              <span style="font-size:0.68rem;color:#888">Frame Map</span>
              <button class="ctrl-btn" id="bloomToggle" style="padding:3px 8px;font-size:0.6rem">Show Bloom</button>
            </div>
            <div class="structure-view" id="structureView"></div>
          </div>
          <div class="tab-content" id="tab-gop">
            <div class="gop-diagram" id="gopDiagram"></div>
          </div>
          <div class="tab-content" id="tab-export">
            <button class="ctrl-btn" id="copyBtn" style="margin-bottom:6px;font-size:0.6rem">Copy JSON</button>
            <div class="export-data" id="exportData">{}</div>
          </div>
        </div>
      </div>

      <!-- COL 3: Simulation -->
      <div>
        <div class="panel">
          <div class="panel-title">
            <span>Datamosh Simulation</span>
            <span class="badge inactive" id="bloomBadge">MONITORING</span>
          </div>
          <div class="video-wrap"><canvas id="outputCanvas"></canvas></div>
          <div class="ctrl-row">
            <button class="ctrl-btn active" id="btnDrag">Pixel Drag</button>
            <button class="ctrl-btn" id="btnBloom">Bloom</button>
            <button class="ctrl-btn" id="btnCombined">Combined</button>
            <button class="ctrl-btn" id="btnNormal">Normal</button>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Effect Parameters</div>
          <div class="slider-group">
            <div class="slider-label"><span>Vector Multiplier</span><span id="vecMultVal">3×</span></div>
            <input type="range" id="vecMultSlider" min="1" max="12" value="3">
          </div>
          <div class="slider-group">
            <div class="slider-label"><span>Trail Decay</span><span id="decayVal">5%</span></div>
            <input type="range" id="decaySlider" min="1" max="25" value="5">
          </div>
          <div class="slider-group">
            <div class="slider-label"><span>Color Bleed</span><span id="bleedVal">15%</span></div>
            <input type="range" id="bleedSlider" min="0" max="50" value="15">
          </div>
        </div>
        
        <div class="panel">
          <div class="info-box" style="margin:0">
            <strong>Pixel Drag:</strong> Motion vectors displace pixels directionally; trails accumulate.<br><br>
            <strong>Bloom:</strong> Scene cut freezes frame; new motion vectors displace frozen pixels.
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer>
    Datamosh Lab — A Glitch Pedagogy Tool<br>
    Created by Ernesto Peña | <a href="https://ernestopena.com" target="_blank">ernestopena.com</a>
  </footer>

  <script>
    // === CONFIG ===
    const BLOCK = 16, SEARCH = 16;
    
    // === STATE ===
    let frames = [], duration = 0, threshold = 5, currentIdx = 0;
    let storedMotionFields = []; // Store motion vectors from analysis
    let isPlaying = false, analysisComplete = false, showBloom = false;
    
    let mode = 'drag', vecMult = 3, trailDecay = 0.05, colorBleed = 0.15;
    let prevFrameData = null, motionField = null;
    let frozenFrame = null, isBloomActive = false, bloomAge = 0;

    // === DOM ===
    const video = document.getElementById('video');
    const motionCanvas = document.getElementById('motionCanvas'), motionCtx = motionCanvas.getContext('2d');
    const outputCanvas = document.getElementById('outputCanvas'), outputCtx = outputCanvas.getContext('2d', { willReadFrequently: true });
    
    const workCanvas = document.createElement('canvas'), workCtx = workCanvas.getContext('2d', { willReadFrequently: true });
    const analysisCanvas = document.createElement('canvas'), analysisCtx = analysisCanvas.getContext('2d', { willReadFrequently: true });

    // === FILE ===
    document.getElementById('fileInput').addEventListener('change', function(e) { 
      if (e.target.files[0]) loadVideo(e.target.files[0]); 
    });
    var uploadArea = document.getElementById('uploadArea');
    uploadArea.addEventListener('dragover', function(e) { e.preventDefault(); uploadArea.classList.add('dragover'); });
    uploadArea.addEventListener('dragleave', function() { uploadArea.classList.remove('dragover'); });
    uploadArea.addEventListener('drop', function(e) { 
      e.preventDefault(); 
      uploadArea.classList.remove('dragover'); 
      if (e.dataTransfer.files[0] && e.dataTransfer.files[0].type.startsWith('video/')) {
        loadVideo(e.dataTransfer.files[0]); 
      }
    });

    function loadVideo(file) {
      video.src = URL.createObjectURL(file);
      video.addEventListener('loadedmetadata', function() {
        var w = video.videoWidth, h = video.videoHeight;
        motionCanvas.width = w; motionCanvas.height = h;
        outputCanvas.width = w; outputCanvas.height = h;
        workCanvas.width = w; workCanvas.height = h;
        analysisCanvas.width = 160; 
        analysisCanvas.height = Math.round(h/w*160);
        duration = video.duration;
        document.getElementById('content').classList.remove('hidden');
        document.getElementById('durLabel').textContent = formatTime(duration);
        analyzeVideo();
      }, { once: true });
    }

    // === ANALYSIS ===
    // Mini motion estimation for analysis (smaller blocks for speed)
    function estimateMotionMini(prev, curr, w, h) {
      var blockSize = 8;
      var searchRange = 8;
      var bx = Math.floor(w / blockSize);
      var by = Math.floor(h / blockSize);
      var field = [];
      
      for (var y = 0; y < by; y++) {
        for (var x = 0; x < bx; x++) {
          var ox = x * blockSize;
          var oy = y * blockSize;
          var bestDx = 0, bestDy = 0, bestSAD = Infinity;
          
          // Search for best match
          for (var dy = -searchRange; dy <= searchRange; dy += 2) {
            for (var dx = -searchRange; dx <= searchRange; dx += 2) {
              var tx = ox + dx, ty = oy + dy;
              if (tx < 0 || ty < 0 || tx + blockSize > w || ty + blockSize > h) continue;
              
              var sad = 0;
              for (var py = 0; py < blockSize; py += 2) {
                for (var px = 0; px < blockSize; px += 2) {
                  var i1 = ((oy + py) * w + (ox + px)) * 4;
                  var i2 = ((ty + py) * w + (tx + px)) * 4;
                  sad += Math.abs(curr[i1] - prev[i2]) + Math.abs(curr[i1+1] - prev[i2+1]) + Math.abs(curr[i1+2] - prev[i2+2]);
                }
              }
              
              if (sad < bestSAD) {
                bestSAD = sad;
                bestDx = dx;
                bestDy = dy;
              }
            }
          }
          
          field.push({ x: ox + blockSize/2, y: oy + blockSize/2, dx: bestDx, dy: bestDy });
        }
      }
      return field;
    }

    function analyzeVideo() {
      frames = [];
      storedMotionFields = [];
      document.getElementById('statusMsg').classList.remove('hidden');
      document.getElementById('statusText').textContent = 'Analyzing frames & motion...';
      
      var fps = 30;
      var total = Math.min(Math.floor(duration * fps), 500);
      var frameIndex = 0;
      var lastDataArray = null;
      var isProcessing = false;
      var maxChangeFound = 0;
      var minChangeFound = 100;
      
      function handleSeeked() {
        if (isProcessing) return;
        isProcessing = true;
        
        analysisCtx.drawImage(video, 0, 0, analysisCanvas.width, analysisCanvas.height);
        var currImageData = analysisCtx.getImageData(0, 0, analysisCanvas.width, analysisCanvas.height);
        var currArray = currImageData.data;
        
        if (frameIndex === 0) {
          frames.push({ time: 0, change: 100, index: 0 });
          storedMotionFields.push([]); // No motion for first frame
        } else if (lastDataArray) {
          var diff = 0;
          var pixelCount = 0;
          for (var j = 0; j < currArray.length; j += 16) {
            diff += Math.abs(currArray[j] - lastDataArray[j]);
            diff += Math.abs(currArray[j+1] - lastDataArray[j+1]);
            diff += Math.abs(currArray[j+2] - lastDataArray[j+2]);
            pixelCount++;
          }
          var avgDiff = diff / (pixelCount * 3);
          var change = (avgDiff / 255) * 100;
          
          if (change > maxChangeFound) maxChangeFound = change;
          if (change < minChangeFound && change > 0) minChangeFound = change;
          
          frames.push({ time: frameIndex/fps, change: change, index: frameIndex });
          
          // Compute and store motion field for this frame
          var motionField = estimateMotionMini(lastDataArray, currArray, analysisCanvas.width, analysisCanvas.height);
          storedMotionFields.push(motionField);
        }
        
        lastDataArray = new Uint8ClampedArray(currArray);
        
        document.getElementById('progressFill').style.width = ((frameIndex/total)*100) + '%';
        frameIndex++;
        
        if (frameIndex >= total) {
          video.removeEventListener('seeked', handleSeeked);
          console.log('Analysis complete. Change range:', minChangeFound.toFixed(2) + '% to ' + maxChangeFound.toFixed(2) + '%');
          console.log('Motion fields stored:', storedMotionFields.length);
          document.getElementById('statusText').textContent = 'Done: ' + frames.length + ' frames';
          analysisComplete = true;
          video.currentTime = 0;
          resetSim();
          updateAllUI();
          setTimeout(function() { 
            document.getElementById('statusMsg').classList.add('hidden'); 
          }, 1200);
        } else {
          isProcessing = false;
          video.currentTime = frameIndex / fps;
        }
      }
      
      video.addEventListener('seeked', handleSeeked);
      video.currentTime = 0;
    }

    // === UI ===
    const formatTime = function(s) { return Math.floor(s/60) + ':' + Math.floor(s%60).toString().padStart(2,'0'); };

    function updateAllUI() {
      if (frames.length === 0) {
        console.log('No frames to display');
        return;
      }
      console.log('Updating UI with', frames.length, 'frames');
      
      // Timeline
      const tl = document.getElementById('timeline');
      const ph = document.getElementById('playhead');
      const existingBars = tl.querySelectorAll('.timeline-bar');
      for (let i = 0; i < existingBars.length; i++) existingBars[i].remove();
      
      let maxChange = 1;
      for (let i = 0; i < frames.length; i++) {
        if (frames[i].change > maxChange) maxChange = frames[i].change;
      }
      
      for (let i = 0; i < frames.length; i++) {
        const f = frames[i];
        const bar = document.createElement('div');
        const type = f.change >= threshold ? 'high' : 'low';
        bar.className = 'timeline-bar ' + type;
        bar.style.left = ((f.time / duration) * 100) + '%';
        bar.style.height = ((f.change / maxChange) * 100) + '%';
        bar.style.width = Math.max(100 / frames.length, 0.4) + '%';
        tl.insertBefore(bar, ph);
      }
      
      // Stats
      let highCount = 0;
      for (let i = 0; i < frames.length; i++) {
        if (frames[i].change >= threshold) highCount++;
      }
      document.getElementById('highCount').textContent = highCount;
      document.getElementById('lowCount').textContent = frames.length - highCount;
      document.getElementById('totalCount').textContent = frames.length;
      
      // Update other views
      updateStructure();
      updateGOP();
      updateExport();
    }

    function updateStructure() {
      const container = document.getElementById('structureView');
      if (!container || frames.length === 0) return;
      container.innerHTML = '';
      for (let i = 0; i < frames.length; i++) {
        const f = frames[i];
        const block = document.createElement('div');
        const type = f.change >= threshold ? 'high' : 'low';
        block.className = 'struct-block ' + type;
        if (showBloom && type === 'high' && i > 0) block.className += ' deleted';
        if (i === currentIdx) block.className += ' current';
        container.appendChild(block);
      }
      console.log('Structure updated:', frames.length, 'blocks');
    }

    function updateGOP() {
      const container = document.getElementById('gopDiagram');
      if (!container || frames.length === 0) return;
      container.innerHTML = '';
      const displayFrames = frames.slice(0, 35);
      let maxChange = 1;
      for (let i = 0; i < displayFrames.length; i++) {
        if (displayFrames[i].change > maxChange) maxChange = displayFrames[i].change;
      }
      for (let i = 0; i < displayFrames.length; i++) {
        const f = displayFrames[i];
        const type = f.change >= threshold ? 'high' : 'low';
        const height = Math.max((f.change / maxChange) * 45, 3);
        const frameEl = document.createElement('div');
        frameEl.className = 'gop-frame';
        
        const bar = document.createElement('div');
        bar.className = 'gop-bar ' + type;
        bar.style.height = height + 'px';
        
        const label = document.createElement('div');
        label.className = 'gop-label';
        label.textContent = i;
        
        frameEl.appendChild(bar);
        frameEl.appendChild(label);
        container.appendChild(frameEl);
      }
      console.log('GOP updated:', displayFrames.length, 'frames');
    }

    function updateExport() {
      if (frames.length === 0) return;
      let iCandidates = 0;
      const frameData = [];
      for (let i = 0; i < frames.length; i++) {
        const f = frames[i];
        const type = f.change >= threshold ? 'I' : 'P';
        if (type === 'I') iCandidates++;
        frameData.push({ i: f.index, t: parseFloat(f.time.toFixed(3)), c: parseFloat(f.change.toFixed(2)), type: type });
      }
      const data = {
        meta: { tool: "Datamosh Lab", author: "Ernesto Peña", date: new Date().toISOString(), duration: duration, threshold: threshold, frames: frames.length },
        stats: { iCandidates: iCandidates, pCandidates: frames.length - iCandidates },
        frames: frameData
      };
      document.getElementById('exportData').textContent = JSON.stringify(data, null, 2);
    }

    // === STEP RENDERING ===
    function renderSteppedFrame(frameIdx) {
      if (frameIdx < 0 || frameIdx >= frames.length) return;
      
      var w = outputCanvas.width, h = outputCanvas.height;
      var analysisW = analysisCanvas.width, analysisH = analysisCanvas.height;
      var scaleX = w / analysisW, scaleY = h / analysisH;
      
      // Get stored motion field and scale it up
      var storedField = storedMotionFields[frameIdx] || [];
      var scaledField = [];
      
      for (var i = 0; i < storedField.length; i++) {
        var v = storedField[i];
        scaledField.push({
          x: v.x * scaleX,
          y: v.y * scaleY,
          dx: v.dx * scaleX,
          dy: v.dy * scaleY
        });
      }
      
      // Draw motion field visualization
      drawMotionFieldScaled(scaledField, scaleX);
      
      // Get current frame data
      workCtx.drawImage(video, 0, 0, w, h);
      var currData = workCtx.getImageData(0, 0, w, h).data;
      
      // Get frame change value
      var frameChange = frames[frameIdx] ? frames[frameIdx].change : 0;
      
      // Update meter display
      document.getElementById('changeMeter').style.width = Math.min(frameChange * 5, 100) + '%';
      document.getElementById('changePercent').textContent = frameChange.toFixed(1) + '%';
      var type = frameChange >= threshold ? 'high' : 'low';
      document.getElementById('frameIndicator').className = 'frame-indicator ' + type;
      document.getElementById('frameIndicator').textContent = type === 'high' ? 'HIGH — I-Frame Candidate' : 'Low — P-Frame Candidate';
      
      // Apply simulation effect using scaled field
      if (scaledField.length > 0) {
        switch (mode) {
          case 'drag': 
            applyDragWithField(currData, scaledField, w, h, scaleX); 
            break;
          case 'bloom': 
            applyBloomWithField(currData, scaledField, w, h, frameChange, scaleX); 
            break;
          case 'combined': 
            applyCombinedWithField(currData, scaledField, w, h, frameChange, scaleX); 
            break;
          default: 
            outputCtx.drawImage(video, 0, 0);
        }
      } else {
        outputCtx.drawImage(video, 0, 0);
      }
      
      // Store for next step
      prevFrameData = new Uint8ClampedArray(currData);
    }
    
    function drawMotionFieldScaled(field, scale) {
      motionCtx.fillStyle = 'rgba(0,0,0,0.75)';
      motionCtx.fillRect(0, 0, motionCanvas.width, motionCanvas.height);
      motionCtx.globalAlpha = 0.25;
      motionCtx.drawImage(video, 0, 0);
      motionCtx.globalAlpha = 1;
      motionCtx.strokeStyle = '#00ff88';
      motionCtx.lineWidth = 1.5;
      
      for (var i = 0; i < field.length; i++) {
        var v = field[i];
        var mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy);
        if (mag < 1 * scale) continue;
        
        motionCtx.beginPath();
        motionCtx.moveTo(v.x, v.y);
        motionCtx.lineTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.stroke();
        
        var a = Math.atan2(v.dy, v.dx);
        motionCtx.beginPath();
        motionCtx.moveTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.lineTo(v.x + v.dx*2 - 4*Math.cos(a-0.5), v.y + v.dy*2 - 4*Math.sin(a-0.5));
        motionCtx.moveTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.lineTo(v.x + v.dx*2 - 4*Math.cos(a+0.5), v.y + v.dy*2 - 4*Math.sin(a+0.5));
        motionCtx.stroke();
      }
    }
    
    function applyDragWithField(curr, field, w, h, scale) {
      var ex = outputCtx.getImageData(0, 0, w, h);
      var blockSize = 8 * scale;
      var bx = Math.floor(w / blockSize);
      
      for (var i = 0; i < ex.data.length; i += 4) { 
        ex.data[i] *= (1-trailDecay); 
        ex.data[i+1] *= (1-trailDecay); 
        ex.data[i+2] *= (1-trailDecay); 
      }
      
      for (var y = 0; y < h; y++) {
        for (var x = 0; x < w; x++) {
          var bi = Math.floor(y / blockSize) * bx + Math.floor(x / blockSize);
          if (bi >= field.length) continue;
          var v = field[bi];
          var sx = Math.max(0, Math.min(w-1, x - v.dx * vecMult));
          var sy = Math.max(0, Math.min(h-1, y - v.dy * vecMult));
          var si = (Math.floor(sy) * w + Math.floor(sx)) * 4;
          var di = (y * w + x) * 4;
          var mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy) / (8 * scale);
          var blend = Math.min(0.8, 0.3 + mag);
          ex.data[di] = ex.data[di]*(1-blend) + curr[si]*blend;
          ex.data[di+1] = ex.data[di+1]*(1-blend) + curr[si+1]*blend;
          ex.data[di+2] = ex.data[di+2]*(1-blend) + curr[si+2]*blend;
          ex.data[di+3] = 255;
        }
      }
      outputCtx.putImageData(ex, 0, 0);
    }
    
    function applyBloomWithField(curr, field, w, h, change, scale) {
      if (change >= threshold && !isBloomActive) {
        frozenFrame = outputCtx.getImageData(0, 0, w, h);
        var sum = 0; 
        for (var i = 0; i < 1000; i += 4) sum += frozenFrame.data[i];
        if (sum < 100 && prevFrameData) frozenFrame = new ImageData(new Uint8ClampedArray(prevFrameData), w, h);
        isBloomActive = true; 
        bloomAge = 0; 
        updateBloomBadge();
      }
      
      if (isBloomActive && frozenFrame) {
        var out = new ImageData(w, h);
        var blockSize = 8 * scale;
        var bx = Math.floor(w / blockSize);
        var decay = Math.max(0, 1 - bloomAge * 0.012);
        
        for (var y = 0; y < h; y++) {
          for (var x = 0; x < w; x++) {
            var bi = Math.floor(y / blockSize) * bx + Math.floor(x / blockSize);
            var v = bi < field.length ? field[bi] : {dx:0, dy:0};
            var sx = Math.max(0, Math.min(w-1, x - v.dx * vecMult * decay));
            var sy = Math.max(0, Math.min(h-1, y - v.dy * vecMult * decay));
            var si = (Math.floor(sy) * w + Math.floor(sx)) * 4;
            var di = (y * w + x) * 4;
            var bleed = colorBleed * decay;
            out.data[di] = frozenFrame.data[si]*(1-bleed) + curr[di]*bleed;
            out.data[di+1] = frozenFrame.data[si+1]*(1-bleed) + curr[di+1]*bleed;
            out.data[di+2] = frozenFrame.data[si+2]*(1-bleed) + curr[di+2]*bleed;
            out.data[di+3] = 255;
          }
        }
        outputCtx.putImageData(out, 0, 0);
        frozenFrame = out; 
        bloomAge++;
        if (decay < 0.1) { isBloomActive = false; updateBloomBadge(); }
      } else {
        outputCtx.drawImage(video, 0, 0);
      }
    }
    
    function applyCombinedWithField(curr, field, w, h, change, scale) {
      if (change >= threshold && !isBloomActive) {
        frozenFrame = outputCtx.getImageData(0, 0, w, h);
        var sum = 0; 
        for (var i = 0; i < 1000; i += 4) sum += frozenFrame.data[i];
        if (sum < 100 && prevFrameData) frozenFrame = new ImageData(new Uint8ClampedArray(prevFrameData), w, h);
        isBloomActive = true; 
        bloomAge = 0; 
        updateBloomBadge();
      }
      
      var ex = outputCtx.getImageData(0, 0, w, h);
      var blockSize = 8 * scale;
      var bx = Math.floor(w / blockSize);
      var decay = isBloomActive ? Math.max(0, 1 - bloomAge * 0.01) : 0;
      
      for (var i = 0; i < ex.data.length; i += 4) { 
        ex.data[i] *= (1-trailDecay*0.5); 
        ex.data[i+1] *= (1-trailDecay*0.5); 
        ex.data[i+2] *= (1-trailDecay*0.5); 
      }
      
      var src = isBloomActive && frozenFrame ? frozenFrame.data : curr;
      
      for (var y = 0; y < h; y++) {
        for (var x = 0; x < w; x++) {
          var bi = Math.floor(y / blockSize) * bx + Math.floor(x / blockSize);
          var v = bi < field.length ? field[bi] : {dx:0, dy:0};
          var mult = isBloomActive ? vecMult * (1 + decay) : vecMult;
          var sx = Math.max(0, Math.min(w-1, x - v.dx * mult));
          var sy = Math.max(0, Math.min(h-1, y - v.dy * mult));
          var si = (Math.floor(sy) * w + Math.floor(sx)) * 4;
          var di = (y * w + x) * 4;
          var mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy) / (8 * scale);
          var blend = Math.min(0.7, 0.2 + mag);
          var r = src[si], g = src[si+1], b = src[si+2];
          if (isBloomActive) { 
            var bl = colorBleed * decay; 
            r = r*(1-bl) + curr[di]*bl; 
            g = g*(1-bl) + curr[di+1]*bl; 
            b = b*(1-bl) + curr[di+2]*bl; 
          }
          ex.data[di] = ex.data[di]*(1-blend) + r*blend;
          ex.data[di+1] = ex.data[di+1]*(1-blend) + g*blend;
          ex.data[di+2] = ex.data[di+2]*(1-blend) + b*blend;
          ex.data[di+3] = 255;
        }
      }
      outputCtx.putImageData(ex, 0, 0);
      if (isBloomActive) { frozenFrame = ex; bloomAge++; if (decay < 0.05) { isBloomActive = false; updateBloomBadge(); } }
    }

    // === MOTION ESTIMATION ===
    function estimateMotion(prev, curr, w, h) {
      const bx = Math.floor(w/BLOCK), by = Math.floor(h/BLOCK), field = [];
      for (let y = 0; y < by; y++) {
        for (let x = 0; x < bx; x++) {
          const ox = x*BLOCK, oy = y*BLOCK;
          let bestDx = 0, bestDy = 0, bestSAD = Infinity;
          for (let dy = -SEARCH; dy <= SEARCH; dy += 2) {
            for (let dx = -SEARCH; dx <= SEARCH; dx += 2) {
              const tx = ox+dx, ty = oy+dy;
              if (tx < 0 || ty < 0 || tx+BLOCK > w || ty+BLOCK > h) continue;
              let sad = 0;
              for (let py = 0; py < BLOCK; py += 2) {
                for (let px = 0; px < BLOCK; px += 2) {
                  const i1 = ((oy+py)*w+(ox+px))*4, i2 = ((ty+py)*w+(tx+px))*4;
                  sad += Math.abs(curr[i1]-prev[i2]) + Math.abs(curr[i1+1]-prev[i2+1]) + Math.abs(curr[i1+2]-prev[i2+2]);
                }
              }
              if (sad < bestSAD) { bestSAD = sad; bestDx = dx; bestDy = dy; }
            }
          }
          field.push({ x: ox+BLOCK/2, y: oy+BLOCK/2, dx: bestDx, dy: bestDy });
        }
      }
      return field;
    }

    function calcSceneChange(field) {
      let total = 0;
      field.forEach(v => total += Math.sqrt(v.dx*v.dx + v.dy*v.dy));
      return (total / field.length) / SEARCH * 100;
    }

    // === RENDERING ===
    function drawMotionField(field) {
      motionCtx.fillStyle = 'rgba(0,0,0,0.75)';
      motionCtx.fillRect(0, 0, motionCanvas.width, motionCanvas.height);
      motionCtx.globalAlpha = 0.25;
      motionCtx.drawImage(video, 0, 0);
      motionCtx.globalAlpha = 1;
      motionCtx.strokeStyle = '#00ff88';
      motionCtx.lineWidth = 1.5;
      field.forEach(v => {
        const mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy);
        if (mag < 1) return;
        motionCtx.beginPath();
        motionCtx.moveTo(v.x, v.y);
        motionCtx.lineTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.stroke();
        const a = Math.atan2(v.dy, v.dx);
        motionCtx.beginPath();
        motionCtx.moveTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.lineTo(v.x + v.dx*2 - 4*Math.cos(a-0.5), v.y + v.dy*2 - 4*Math.sin(a-0.5));
        motionCtx.moveTo(v.x + v.dx*2, v.y + v.dy*2);
        motionCtx.lineTo(v.x + v.dx*2 - 4*Math.cos(a+0.5), v.y + v.dy*2 - 4*Math.sin(a+0.5));
        motionCtx.stroke();
      });
    }

    function applyDrag(curr, field, w, h) {
      const ex = outputCtx.getImageData(0, 0, w, h), bx = Math.floor(w/BLOCK);
      for (let i = 0; i < ex.data.length; i += 4) { ex.data[i] *= (1-trailDecay); ex.data[i+1] *= (1-trailDecay); ex.data[i+2] *= (1-trailDecay); }
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const bi = Math.floor(y/BLOCK)*bx + Math.floor(x/BLOCK);
          if (bi >= field.length) continue;
          const v = field[bi];
          const sx = Math.max(0, Math.min(w-1, x - v.dx*vecMult)), sy = Math.max(0, Math.min(h-1, y - v.dy*vecMult));
          const si = (Math.floor(sy)*w + Math.floor(sx))*4, di = (y*w+x)*4;
          const mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy) / SEARCH;
          const blend = Math.min(0.8, 0.3 + mag);
          ex.data[di] = ex.data[di]*(1-blend) + curr[si]*blend;
          ex.data[di+1] = ex.data[di+1]*(1-blend) + curr[si+1]*blend;
          ex.data[di+2] = ex.data[di+2]*(1-blend) + curr[si+2]*blend;
          ex.data[di+3] = 255;
        }
      }
      outputCtx.putImageData(ex, 0, 0);
    }

    function applyBloomEffect(curr, field, w, h, sc) {
      if (sc > threshold && !isBloomActive) {
        frozenFrame = outputCtx.getImageData(0, 0, w, h);
        let sum = 0; for (let i = 0; i < 1000; i += 4) sum += frozenFrame.data[i];
        if (sum < 100 && prevFrameData) frozenFrame = new ImageData(new Uint8ClampedArray(prevFrameData), w, h);
        isBloomActive = true; bloomAge = 0; updateBloomBadge();
      }
      if (isBloomActive && frozenFrame) {
        const out = new ImageData(w, h), bx = Math.floor(w/BLOCK);
        const decay = Math.max(0, 1 - bloomAge*0.012);
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const bi = Math.floor(y/BLOCK)*bx + Math.floor(x/BLOCK);
            const v = bi < field.length ? field[bi] : {dx:0, dy:0};
            const sx = Math.max(0, Math.min(w-1, x - v.dx*vecMult*decay)), sy = Math.max(0, Math.min(h-1, y - v.dy*vecMult*decay));
            const si = (Math.floor(sy)*w + Math.floor(sx))*4, di = (y*w+x)*4;
            const bleed = colorBleed * decay;
            out.data[di] = frozenFrame.data[si]*(1-bleed) + curr[di]*bleed;
            out.data[di+1] = frozenFrame.data[si+1]*(1-bleed) + curr[di+1]*bleed;
            out.data[di+2] = frozenFrame.data[si+2]*(1-bleed) + curr[di+2]*bleed;
            out.data[di+3] = 255;
          }
        }
        outputCtx.putImageData(out, 0, 0);
        frozenFrame = out; bloomAge++;
        if (decay < 0.1) { isBloomActive = false; updateBloomBadge(); }
      } else {
        outputCtx.drawImage(video, 0, 0);
      }
    }

    function applyCombined(curr, field, w, h, sc) {
      if (sc > threshold && !isBloomActive) {
        frozenFrame = outputCtx.getImageData(0, 0, w, h);
        let sum = 0; for (let i = 0; i < 1000; i += 4) sum += frozenFrame.data[i];
        if (sum < 100 && prevFrameData) frozenFrame = new ImageData(new Uint8ClampedArray(prevFrameData), w, h);
        isBloomActive = true; bloomAge = 0; updateBloomBadge();
      }
      const ex = outputCtx.getImageData(0, 0, w, h), bx = Math.floor(w/BLOCK);
      const decay = isBloomActive ? Math.max(0, 1 - bloomAge*0.01) : 0;
      for (let i = 0; i < ex.data.length; i += 4) { ex.data[i] *= (1-trailDecay*0.5); ex.data[i+1] *= (1-trailDecay*0.5); ex.data[i+2] *= (1-trailDecay*0.5); }
      const src = isBloomActive && frozenFrame ? frozenFrame.data : curr;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const bi = Math.floor(y/BLOCK)*bx + Math.floor(x/BLOCK);
          const v = bi < field.length ? field[bi] : {dx:0,dy:0};
          const mult = isBloomActive ? vecMult*(1+decay) : vecMult;
          const sx = Math.max(0, Math.min(w-1, x - v.dx*mult)), sy = Math.max(0, Math.min(h-1, y - v.dy*mult));
          const si = (Math.floor(sy)*w + Math.floor(sx))*4, di = (y*w+x)*4;
          const mag = Math.sqrt(v.dx*v.dx + v.dy*v.dy)/SEARCH;
          const blend = Math.min(0.7, 0.2+mag);
          let r = src[si], g = src[si+1], b = src[si+2];
          if (isBloomActive) { const bl = colorBleed*decay; r = r*(1-bl)+curr[di]*bl; g = g*(1-bl)+curr[di+1]*bl; b = b*(1-bl)+curr[di+2]*bl; }
          ex.data[di] = ex.data[di]*(1-blend) + r*blend;
          ex.data[di+1] = ex.data[di+1]*(1-blend) + g*blend;
          ex.data[di+2] = ex.data[di+2]*(1-blend) + b*blend;
          ex.data[di+3] = 255;
        }
      }
      outputCtx.putImageData(ex, 0, 0);
      if (isBloomActive) { frozenFrame = ex; bloomAge++; if (decay < 0.05) { isBloomActive = false; updateBloomBadge(); } }
    }

    function updateBloomBadge() {
      var b = document.getElementById('bloomBadge');
      if (isBloomActive) {
        b.className = 'badge active';
        b.textContent = 'BLOOM ACTIVE';
      } else {
        b.className = 'badge inactive';
        b.textContent = 'MONITORING';
      }
    }

    function resetSim() {
      prevFrameData = null; motionField = null; frozenFrame = null;
      isBloomActive = false; bloomAge = 0;
      outputCtx.fillStyle = '#000';
      outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
      motionCtx.fillStyle = '#000';
      motionCtx.fillRect(0, 0, motionCanvas.width, motionCanvas.height);
      updateBloomBadge();
    }

    // === MAIN LOOP ===
    function processFrame() {
      if (!isPlaying) return;
      const w = workCanvas.width, h = workCanvas.height;
      
      workCtx.drawImage(video, 0, 0, w, h);
      const curr = workCtx.getImageData(0, 0, w, h).data;
      
      // Update time display
      var t = video.currentTime;
      document.getElementById('timeDisplay').textContent = formatTime(t) + '/' + formatTime(duration);
      document.getElementById('playhead').style.left = ((t/duration)*100) + '%';
      
      // Find current analysis frame
      for (let i = frames.length-1; i >= 0; i--) { if (frames[i].time <= t) { currentIdx = i; break; } }
      
      if (prevFrameData) {
        motionField = estimateMotion(prevFrameData, curr, w, h);
        const sc = calcSceneChange(motionField);
        
        // Update meter
        document.getElementById('changeMeter').style.width = Math.min(sc, 100) + '%';
        document.getElementById('changePercent').textContent = sc.toFixed(1) + '%';
        const type = sc >= threshold ? 'high' : 'low';
        document.getElementById('frameIndicator').className = 'frame-indicator ' + type;
        document.getElementById('frameIndicator').textContent = type === 'high' ? 'HIGH — I-Frame Candidate' : 'Low — P-Frame Candidate';
        
        drawMotionField(motionField);
        
        switch (mode) {
          case 'drag': applyDrag(curr, motionField, w, h); break;
          case 'bloom': applyBloomEffect(curr, motionField, w, h, sc); break;
          case 'combined': applyCombined(curr, motionField, w, h, sc); break;
          default: outputCtx.drawImage(video, 0, 0);
        }
      } else {
        outputCtx.drawImage(video, 0, 0);
      }
      
      prevFrameData = new Uint8ClampedArray(curr);
      requestAnimationFrame(processFrame);
    }

    // === CONTROLS ===
    document.getElementById('playBtn').addEventListener('click', function() {
      if (isPlaying) { 
        video.pause(); 
        isPlaying = false; 
        document.getElementById('playBtn').textContent = '▶ Play'; 
      } else { 
        video.play(); 
        isPlaying = true; 
        document.getElementById('playBtn').textContent = '❚❚'; 
        requestAnimationFrame(processFrame); 
      }
    });
    document.getElementById('stepBackBtn').addEventListener('click', function() { 
      video.pause(); 
      isPlaying = false; 
      document.getElementById('playBtn').textContent = '▶ Play'; 
      
      // Go back one frame
      video.currentTime = Math.max(0, video.currentTime - 1/30);
      
      // Find corresponding frame index
      var targetTime = video.currentTime;
      var frameIdx = 0;
      for (var i = 0; i < frames.length; i++) {
        if (frames[i].time <= targetTime) {
          frameIdx = i;
        } else {
          break;
        }
      }
      currentIdx = frameIdx;
      
      // Wait for seek then render
      video.onseeked = function() {
        video.onseeked = null;
        document.getElementById('timeDisplay').textContent = formatTime(video.currentTime) + '/' + formatTime(duration);
        document.getElementById('playhead').style.left = ((video.currentTime / duration) * 100) + '%';
        renderSteppedFrame(frameIdx);
        updateStructure();
      };
    });
    document.getElementById('stepBtn').addEventListener('click', function() { 
      video.pause(); 
      isPlaying = false; 
      document.getElementById('playBtn').textContent = '▶ Play'; 
      
      // Advance by one frame
      video.currentTime += 1/30;
      
      // Find corresponding frame index
      var targetTime = video.currentTime;
      var frameIdx = 0;
      for (var i = 0; i < frames.length; i++) {
        if (frames[i].time <= targetTime) {
          frameIdx = i;
        } else {
          break;
        }
      }
      currentIdx = frameIdx;
      
      // Wait for seek then render
      video.onseeked = function() {
        video.onseeked = null;
        
        // Update time display
        document.getElementById('timeDisplay').textContent = formatTime(video.currentTime) + '/' + formatTime(duration);
        document.getElementById('playhead').style.left = ((video.currentTime / duration) * 100) + '%';
        
        // Render using stored motion data
        renderSteppedFrame(frameIdx);
        
        // Update structure view to highlight current frame
        updateStructure();
      };
    });
    document.getElementById('resetBtn').addEventListener('click', function() { 
      video.pause(); 
      video.currentTime = 0; 
      isPlaying = false; 
      document.getElementById('playBtn').textContent = '▶ Play'; 
      resetSim(); 
      updateStructure(); 
    });

    ['btnDrag','btnBloom','btnCombined','btnNormal'].forEach(function(id) {
      document.getElementById(id).addEventListener('click', function() {
        mode = id.replace('btn','').toLowerCase();
        ['btnDrag','btnBloom','btnCombined','btnNormal'].forEach(function(b) { 
          document.getElementById(b).classList.remove('active'); 
        });
        document.getElementById(id).classList.add('active');
        resetSim();
      });
    });

    document.getElementById('threshSlider').addEventListener('input', function(e) { 
      threshold = parseInt(e.target.value); 
      document.getElementById('threshVal').textContent = threshold + '%'; 
      // Position marker as percentage of 20 (max slider value)
      document.getElementById('threshMarker').style.left = ((threshold / 20) * 100) + '%'; 
      if (analysisComplete) updateAllUI(); 
    });
    document.getElementById('vecMultSlider').addEventListener('input', function(e) { vecMult = parseInt(e.target.value); document.getElementById('vecMultVal').textContent = e.target.value + '×'; });
    document.getElementById('decaySlider').addEventListener('input', function(e) { trailDecay = e.target.value/100; document.getElementById('decayVal').textContent = e.target.value + '%'; });
    document.getElementById('bleedSlider').addEventListener('input', function(e) { colorBleed = e.target.value/100; document.getElementById('bleedVal').textContent = e.target.value + '%'; });

    var tabBtns = document.querySelectorAll('.tab-btn');
    for (var i = 0; i < tabBtns.length; i++) {
      tabBtns[i].addEventListener('click', function(e) {
        var allBtns = document.querySelectorAll('.tab-btn');
        var allContents = document.querySelectorAll('.tab-content');
        for (var j = 0; j < allBtns.length; j++) allBtns[j].classList.remove('active');
        for (var j = 0; j < allContents.length; j++) allContents[j].classList.remove('active');
        e.target.classList.add('active');
        document.getElementById('tab-' + e.target.getAttribute('data-tab')).classList.add('active');
      });
    }

    document.getElementById('bloomToggle').addEventListener('click', function() { 
      showBloom = !showBloom; 
      this.textContent = showBloom ? 'Normal' : 'Show Bloom'; 
      if (showBloom) {
        this.classList.add('active');
      } else {
        this.classList.remove('active');
      }
      updateStructure(); 
    });
    document.getElementById('timeline').addEventListener('click', function(e) { 
      if (!duration) return; 
      var rect = document.getElementById('timeline').getBoundingClientRect();
      var targetTime = ((e.clientX - rect.left) / rect.width) * duration;
      video.currentTime = targetTime;
      
      // If not playing, render the stepped frame
      if (!isPlaying) {
        var frameIdx = 0;
        for (var i = 0; i < frames.length; i++) {
          if (frames[i].time <= targetTime) {
            frameIdx = i;
          } else {
            break;
          }
        }
        currentIdx = frameIdx;
        
        video.onseeked = function() {
          video.onseeked = null;
          document.getElementById('timeDisplay').textContent = formatTime(video.currentTime) + '/' + formatTime(duration);
          document.getElementById('playhead').style.left = ((video.currentTime / duration) * 100) + '%';
          renderSteppedFrame(frameIdx);
          updateStructure();
        };
      }
    });
    document.getElementById('copyBtn').addEventListener('click', function() { 
      var btn = document.getElementById('copyBtn');
      navigator.clipboard.writeText(document.getElementById('exportData').textContent).then(function() {
        btn.textContent = 'Copied!'; 
        setTimeout(function() { btn.textContent = 'Copy JSON'; }, 1200);
      }); 
    });
  </script>
</body>
</html>
